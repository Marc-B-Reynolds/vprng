# Dumb mini makefile:
# 0) assumes clang/GCC like options
# 1) every .c file is to be built into an executable

# if CC is the default (not environment varible nor supplied to make, then default
ifeq ($(origin CC),default)
  CC = clang-15
endif

IDIRS  = -I.. 
CFLAGS = -g3 -O3 ${IDIRS} -march=native -Wall -Wextra -Wconversion -Wno-unused-function -Wno-empty-body -fno-math-errno
LDLIBS = -lm

FSRC    := ${wildcard *.c}
SRC      := ${filter-out xorshift.c vprng_testu01.c, ${FSRC}}
HEADERS  := ${wildcard *.h}
TARGETS  := ${SRC:.c=}
FTARGETS := ${FSRC:.c=}

# OS detection.
ifeq ($(OS),Windows_NT)
# Default to GCC on Windows (presumably MinGW).
  CC         = gcc
# Force the .exe suffix so that Makefile looks at the correct
# target when deciding what to rebuild.
  EXESUFFIX := .exe
  TARGETS   := $(addsuffix $(EXESUFFIX),$(TARGETS))
  FTARGETS  := $(addsuffix $(EXESUFFIX),$(FTARGETS))
# Force static linkning so that binary doesn't require
# MinGW's DLLs to run.
  LDFLAGS   += -static
endif

all:    ${TARGETS}

clean:
	-${RM} ${FTARGETS}

distclean:	clean
	-${RM} .makedep *~

.makedep:
	@-echo "building dependencies"
	@-echo "# autogenerated by Makefile" > .makedep
	@$(foreach file, $(FSRC), ${CC} ${IDIRS} -MM -MQ${file:.c=}  $(file) >> .makedep;)

# even hacker
makedata_vpcg:
	${CC} -DVPRNG_INCLUDE=\"vpcg.h\" ${CFLAGS} makedata.c -o $@ ${LDLIBS}

makedata_vsplitmix:
	${CC} -DVPRNG_INCLUDE=\"vsplitmix.h\" ${CFLAGS} makedata.c -o $@ ${LDLIBS}

vprng_testu01:vprng_testu01.c
	${CC} ${CFLAGS} $< -o $@ ${LDLIBS} -lmylib -ltestu01

xorshift:xorshift.c
	${CC} ${CFLAGS} $< -o $@ ${LDLIBS} -lm4ri

%$(EXESUFFIX):%.c	Makefile
	${CC} ${CFLAGS} $< -o $@ ${LDFLAGS} ${LDLIBS}

-include .makedep
